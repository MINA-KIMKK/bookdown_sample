[["propensity-score-matching.html", "Section 3 Propensity Score Matching 3.1 Complete data version 3.2 Balance check (Complete) 3.3 Missing data version 3.4 Balance check (Missing)", " Section 3 Propensity Score Matching Covariate balance Covariate balance is the degree to which the distribution of covariates is similar across levels of the treatment. SMD(Standardized Mean Difference) is the most widely used statistic for the assessment of balance after PSM. SMD for continuous variables : \\[SMD=\\frac{\\bar X_1-\\bar X_2}{\\sqrt{(S^2_1+S^2_2)/2}}\\] \\(\\bar X_1\\) and \\(\\bar X_2\\) are sample mean for the treated and control groups. \\(S^2_1\\) and \\(S^2_2\\) are sample variance for the treated and control groups. SMD for binary variables : \\[SMD=\\frac{\\hat p_1-\\hat p_2}{\\sqrt{[\\hat p_1(1-\\hat p_1)+\\hat p_2(1-\\hat p_2)]/2}}\\] \\(\\hat p_1\\) and \\(\\hat p_2\\) are prevalence of binary variables in the treated and control groups. If the SMD after matching is less than 0.1, it is determined that the difference by the covariates between the two groups is negligible. Using list dat_imp_list Outcome variable : HTN Follow-up period : DATEDIFF Exposure variable : DM Covariates : Age, Sex, SES, Region, BMI, CCI, Comorbidities(Dyslipidemia, Ischemic heart disease) ## load library library(MatchIt) library(dplyr) source(&quot;cobalt_3.9.0.R&quot;) ## load data load(&quot;Data/dat_imp_list.RData&quot;) final_com &lt;- read.csv(&#39;Data/final_com.csv&#39;, header=T) ## Formula formula.mat &lt;- formula(DM ~ AGE + SEX + SES + REGION + BMI + CCI + DYS + IHD) Use matchit() function in MatchIt package to create treatment and control groups balanced on included covariates. method=‘nearest’ : nearest neighbor matching on the propensity score ratio=k : the number of controls matched to each treated unit for k:1 matching caliper : Units whose propensity score difference is larger than the caliper will not be paired, and some treated units may therefore not receive a match. 3.1 Complete data version 1:5 nearest matching _ caliper: 0.4 ## Optimal caliper ps &lt;- glm(formula.mat,data=final_com, family = &#39;binomial&#39;) ps$pscore&lt;- predict(ps, type=&#39;link&#39;) 0.2*sd(ps$pscore) ## [1] 0.2122638 set.seed(1) mat &lt;- matchit(formula.mat, method = &#39;nearest&#39;, data=final_com, ratio=5, caliper=0.4) matdat &lt;- match.data(mat) %&gt;% select(-subclass) # 서버 R에서는 subclass 자동생성 안됨 # adding an matching index as a subclass to matdat and store as dat_mat # as.numeric(tmp[,1:ratio]), rep(c(1:nrow(tmp)),ratio+1) tmp &lt;- na.omit(mat$match.matrix) matid &lt;- data.frame(rowid=c(as.numeric(rownames(tmp)), as.numeric(tmp[,1:5])), subclass=rep(c(1:nrow(tmp)),6)) matid$RN_INDI &lt;- final_com$RN_INDI[matid$row] dat_mat &lt;- matdat %&gt;% left_join(matid %&gt;% select(RN_INDI,subclass),by = &#39;RN_INDI&#39;) %&gt;% filter(is.na(subclass)==F) ## Save matching data save(dat_mat,file=&quot;Data/dat_mat.RData&quot;) 3.2 Balance check (Complete) bal.ch &lt;- function(before_data, after_data, group){ group&lt;-deparse(substitute(group)) # SMD before matching bal_check_un &lt;- bal.tab.data.frame(before_data[covariates], treat=before_data[,group], binary=&quot;std&quot;, s.d.denom = &quot;pooled&quot;) un &lt;- abs(bal_check_un$Balance$Diff.Un) # SMD after matching bal_check_adj &lt;- bal.tab.data.frame(after_data[covariates], treat=after_data[,group], binary=&quot;std&quot;, s.d.denom = &quot;pooled&quot;) adj &lt;- abs(bal_check_adj$Balance$Diff.Un) bal.res &lt;- data.frame(un=round(un,3),adj=round(adj,3)) rownames(bal.res) &lt;- rownames(bal_check_un$Balance) return(bal.res) } covariates &lt;- c(&quot;AGE&quot;,&quot;SEX&quot;,&quot;SES&quot;,&quot;REGION&quot;,&quot;BMI&quot;,&quot;CCI&quot;,&quot;DYS&quot;,&quot;IHD&quot;) bal.ch(before_matching_data, after_matching_data, group variable) bal.ch(final_com, dat_mat, DM) ## un adj ## AGE 0.997 0.033 ## SEX_2 0.029 0.017 ## SES 0.159 0.201 ## REGION 0.087 0.014 ## BMI 0.273 0.147 ## CCI 0.202 0.216 ## DYS 0.519 0.199 ## IHD 0.036 0.130 3.3 Missing data version 1:3 nearest matching _ caliper: 0.3, 0.35, 0.4 ## Optimal caliper opt.clp &lt;- c() for (i in 1:length(dat_imp_list)){ ps &lt;- glm(formula.mat,data=dat_imp_list[[i]], family = &#39;binomial&#39;) ps$pscore&lt;- predict(ps, type=&#39;link&#39;) opt.clp &lt;- c(opt.clp, 0.2*sd(ps$pscore)) } opt.clp; mean(opt.clp) ## [1] 0.2899617 0.2709918 0.2828702 0.2778456 0.2794823 0.2710618 0.2745410 ## [8] 0.2706783 0.2788889 0.2695220 ## [1] 0.2765843 caliper &lt;- c(0.3,0.35,0.4) for (i in 1:length(dat_imp_list)){ for (j in caliper){ set.seed(1) mat &lt;- matchit(formula.mat, method = &#39;nearest&#39;, data=dat_imp_list[[i]], ratio=3, caliper=j) matdat &lt;- match.data(mat) %&gt;% select(-subclass) # 서버 R에서는 subclass 자동생성 안됨 # adding an matching index as a subclass to matdat and store as dat_mati_j # as.numeric(tmp[,1:ratio]), rep(c(1:nrow(tmp)),ratio+1) tmp &lt;- na.omit(mat$match.matrix) matid &lt;- data.frame(rowid=c(as.numeric(rownames(tmp)), as.numeric(tmp[,1:3])), subclass=rep(c(1:nrow(tmp)),4)) matid$RN_INDI &lt;- dat_imp_list[[i]]$RN_INDI[matid$row] assign(paste0(&#39;dat_mat&#39;,i,&quot;_&quot;,j), matdat %&gt;% left_join(matid %&gt;% select(RN_INDI,subclass),by = &#39;RN_INDI&#39;) %&gt;% filter(is.na(subclass)==F)) } } ## list of 10 matched data dat_mat_list_0.3 &lt;- list(dat_mat1_0.3,dat_mat2_0.3,dat_mat3_0.3,dat_mat4_0.3,dat_mat5_0.3,dat_mat6_0.3,dat_mat7_0.3,dat_mat8_0.3,dat_mat9_0.3,dat_mat10_0.3) dat_mat_list_0.35 &lt;- list(dat_mat1_0.35,dat_mat2_0.35,dat_mat3_0.35,dat_mat4_0.35,dat_mat5_0.35,dat_mat6_0.35,dat_mat7_0.35,dat_mat8_0.35,dat_mat9_0.35,dat_mat10_0.35) dat_mat_list_0.4 &lt;- list(dat_mat1_0.4,dat_mat2_0.4,dat_mat3_0.4,dat_mat4_0.4,dat_mat5_0.4,dat_mat6_0.4,dat_mat7_0.4,dat_mat8_0.4,dat_mat9_0.4,dat_mat10_0.4) ## Save list for matched data save(dat_mat_list_0.3,file=&quot;Data/dat_mat_list_0.3.RData&quot;) save(dat_mat_list_0.35,file=&quot;Data/dat_mat_list_0.35.RData&quot;) save(dat_mat_list_0.4,file=&quot;Data/dat_mat_list_0.4.RData&quot;) 3.4 Balance check (Missing) bal.ch &lt;- function(dat_imp_list, dat_mat_list, group){ group&lt;-deparse(substitute(group)) # SMD before matching bal_check_un &lt;- dat_imp_list %&gt;% lapply(function(x){ bal.tab.data.frame(x[covariates], treat=x[,group], binary=&quot;std&quot;, s.d.denom = &quot;pooled&quot;)}) un &lt;- sapply(bal_check_un, function(x) (abs(x$Balance$Diff.Un))) rownames(un) &lt;- rownames(bal_check_un[[1]]$Balance) # SMD after matching bal_check_adj &lt;- dat_mat_list %&gt;% lapply(function(x){ bal.tab.data.frame(x[covariates], treat=x[,group], binary=&quot;std&quot;, s.d.denom = &quot;pooled&quot;)}) adj &lt;- sapply(bal_check_adj, function(x) (abs(x$Balance$Diff.Un))) rownames(adj) &lt;- rownames(bal_check_adj[[1]]$Balance) bal.res &lt;- list(un=apply(un, 1, summary), adj=apply(adj, 1, summary)) return(data.frame(un=round(bal.res$un[6,],3),adj=round(bal.res$adj[6,],3))) } covariates &lt;- c(&quot;AGE&quot;,&quot;SEX&quot;,&quot;SES&quot;,&quot;REGION&quot;,&quot;BMI&quot;,&quot;CCI&quot;,&quot;DYS&quot;,&quot;IHD&quot;) bal.ch(before_matching_list, after_matching_list, group variable) bal.ch(dat_imp_list, dat_mat_list_0.3, DM) ## un adj ## AGE 1.450 0.041 ## SEX_2 0.020 0.057 ## SES 0.148 0.064 ## REGION 0.006 0.105 ## BMI 0.423 0.079 ## CCI 0.267 0.095 ## DYS 0.435 0.112 ## IHD 0.094 0.077 bal.ch(dat_imp_list, dat_mat_list_0.35, DM) ## un adj ## AGE 1.450 0.040 ## SEX_2 0.020 0.076 ## SES 0.148 0.073 ## REGION 0.006 0.094 ## BMI 0.423 0.084 ## CCI 0.267 0.082 ## DYS 0.435 0.100 ## IHD 0.094 0.101 bal.ch(dat_imp_list, dat_mat_list_0.4, DM) ## un adj ## AGE 1.450 0.037 ## SEX_2 0.020 0.074 ## SES 0.148 0.065 ## REGION 0.006 0.094 ## BMI 0.423 0.062 ## CCI 0.267 0.077 ## DYS 0.435 0.100 ## IHD 0.094 0.100 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
